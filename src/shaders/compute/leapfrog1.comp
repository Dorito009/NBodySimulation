#version 430

layout(local_size_x = 256) in;

struct Body {
    vec4 position;   // .xyz = world-space pos;    .w = (unused)
    vec4 impulse;   // .xyz = world-space vel;    .w = mass
    vec4 acceleration; // .xyz = acceleration; .w = (unused)
};

layout(std430, binding = 0) buffer BodyBuffer {
    Body bodies[];
};
layout(std430, binding = 1) buffer EnergyBuffer {
    vec2 energy[]; // .x = KE, .y = 2 * PE
};

uniform float dt;          // the time step
uniform float G;           // gravitational constant
uniform float epsilon;   // softening parameter to avoid singularities

void main() {
    uint i = gl_GlobalInvocationID.x;
    uint numBodies = int(bodies.length());

    if (i >= numBodies) {
        // Thread out of range â†’ do nothing
        return;
    }

    Body me = bodies[i];
    float m_i = me.impulse.w;
    vec3 pos_i = me.position.xyz;
    vec3 vel_i = me.impulse.xyz;

    float kinetic = 0.5f * m_i * dot(vel_i, vel_i);
    float potential = 0.0f;

    for (uint j = 0u; j < numBodies; ++j) {
        if (j == i) continue;

        Body other = bodies[j];
        vec3 pos_j = other.position.xyz;
        float m_j  = other.impulse.w;

        vec3 r = pos_j - pos_i;
        float distSqr = dot(r, r) + (epsilon * epsilon);
        float invDist  = inversesqrt(distSqr);
        float invDist3 = invDist * invDist * invDist;

        potential += -G * m_i * m_j * invDist; // Potential energy
    }
    // Remove this line
    potential = -G * 100 * m_i * 1/(pow(length(pos_i), 2));


    // Store the kinetic and potential energy
    energy[i] = vec2(kinetic, potential);

    me.impulse.xyz += me.acceleration.xyz * 0.5 * dt;
    me.position.xyz += me.impulse.xyz * dt;

    bodies[i] = me; // Store the updated body data
}